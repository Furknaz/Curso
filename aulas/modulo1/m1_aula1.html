
<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Aula 1: A Objeção Oculta - ConsigFlix</title>
    <link rel="stylesheet" href="../../css/style.css" />
  <script src="../../js/auth.js"></script>
  </head>
  <body>
    <header class="header">
      <div class="header-content">
        <a href="../../index.html" class="back-button">Voltar</a>
      </div>
    </header>
    <div class="lesson-container">
      <section class="video-layout">
        <div class="two-column">
          <div class="left-column">
            <h1 class="lesson-title">
              A Objeção Oculta: Como Ler a Mente do Cliente
            </h1>
            <p class="lesson-description">
              Nesta aula, você aprenderá a ir além das respostas prontas do cliente.
              Vamos desvendar o que realmente impede o fechamento e como identificar a
              verdadeira objeção por trás de frases como "Vou pensar" ou "A taxa está
              alta".
            </p>
            
            <div class="lesson-content">
              <h3>Conteúdo Principal</h3>
              <p>
                Olá, futuro campeão de vendas! Bem-vindo à primeira aula do nosso
                módulo sobre objeções. E vamos começar com o segredo mais importante:
                a objeção que o cliente fala raramente é a objeção real.
              </p>
              <p>
                Pense comigo: quando um cliente diz 'Preciso pensar', ele realmente
                vai montar uma planilha no Excel e comparar propostas? Ou quando ele
                diz 'A taxa está alta', ele de fato tem uma oferta melhor em mãos? Na
                maioria das vezes, não. Essas são apenas defesas, escudos que as
                pessoas usam para não tomar uma decisão.
              </p>
              <p>
                A objeção real é quase sempre emocional. Pode ser medo de se
                endividar, desconfiança no mercado de crédito, vergonha de admitir que
                precisa do dinheiro ou até mesmo a influência de um familiar que disse
                para não fazer empréstimos.
              </p>
              <p>
                Seu trabalho, como especialista, não é responder à objeção
                superficial, mas sim investigar a fundo. A técnica para isso é
                simples: <strong>perguntas abertas e escuta ativa.</strong>
              </p>
              <p>
                Quando o cliente disser: 'Vou analisar outras propostas', não responda
                com 'Mas a minha é a melhor!'. Em vez disso, pergunte com empatia:
              </p>
              <ul>
                <li>
                  'Entendo perfeitamente, Sr. João. E para que sua análise seja
                  completa, o que exatamente o senhor vai comparar? É a taxa, o prazo,
                  o valor da parcela? Me diga para que eu possa garantir que o senhor
                  tenha a melhor informação em mãos.'
                </li>
              </ul>
              <p>
                Essa abordagem muda o jogo. Você sai do modo 'vendedor' e entra no
                modo 'consultor'. Você está ajudando, não empurrando.
              </p>
              <p>
                Outro exemplo: o cliente diz 'A taxa está muito alta'. Em vez de
                justificar, investigue:
              </p>
              <ul>
                <li>
                  'Alta em comparação com o quê, Dona Maria? A senhora tem outra
                  proposta em mãos? Ou talvez a parcela não tenha ficado confortável
                  no seu orçamento?'
                </li>
              </ul>
              <p>
                Percebe a diferença? A primeira resposta gera confronto. A segunda
                gera diálogo. E é no diálogo que você descobre a verdade. Talvez a
                Dona Maria não ache a taxa alta, mas sim a parcela pesada. A solução,
                nesse caso, não é brigar pela taxa, mas talvez ajustar o prazo para
                que a parcela caiba no bolso dela.
              </p>
              <p>
                Lembre-se sempre: a objeção é um pedido de ajuda disfarçado. O cliente
                está dizendo: 'Me ajude a confiar em você', 'Me ajude a entender
                melhor', 'Me prove que esta é a decisão certa'.
              </p>
              <p>
                Sua meta não é 'vencer' a objeção. É entendê-la, acolhê-la e
                resolvê-la junto com o cliente. Quando você faz isso, a venda se torna
                uma consequência natural da confiança que você construiu.
              </p>

              <h3>Exercício/Atividade</h3>
              <p>
                Liste as 3 objeções que você mais ouve no seu dia a dia. Para cada uma
                delas, escreva duas perguntas abertas que você pode usar para
                investigar a objeção real por trás da frase do cliente. O objetivo é
                sair do confronto e abrir um diálogo.
              </p>
            </div>
            
            <a href="modulo1.html" class="back-link">Voltar aos Episódios</a>
          </div>

          <aside class="right-column">
            <div class="video-container">
              <iframe id="lessonIframe" width="680" height="400" src="https://www.youtube.com/embed/dzfS_W4yX-A?si=7KbVn9wYt4bUMXrB" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
              <div class="vc-controls">
                <button class="fp-toggle" id="fpToggleDock" aria-label="Alternar Janela Flutuante">Janela Flutuante</button>
              </div>
            </div>
          </aside>
        </div>
      </section>

      <!-- Floating, resizable player -->
      <div class="floating-player" id="floatingPlayer" role="dialog" aria-label="Player de vídeo">
        <div class="fp-header" id="fpHeader">
          <span class="fp-title">Player</span>
          <div class="fp-controls">
            <!-- control exists in dock now; keep placeholder for semantics -->
          </div>
        </div>
        <div class="fp-content">
          <!-- iframe will be moved here when user activates floating mode -->
        </div>
        <div class="fp-resize-handle fp-resize-bl" id="fpResizeHandleBL" aria-hidden="true"></div>
        <div class="fp-resize-handle fp-resize-br" id="fpResizeHandleBR" aria-hidden="true"></div>
      </div>

      <script>
        (function(){
          const fp = document.getElementById('floatingPlayer');
          const header = document.getElementById('fpHeader');


          // Toggle action: move iframe between dock (right-column) and floating player
          // Toggle button in dock
          const fpToggleDock = document.getElementById('fpToggleDock');
          const dockContainer = document.querySelector('.video-container');
          // reference to the controls wrapper (contains the toggle button)
          let vcControls = dockContainer.querySelector('.vc-controls');
          const fpContent = document.querySelector('.floating-player .fp-content');
          let isFloating = false;

          function activateFloating() {
            const iframe = document.getElementById('lessonIframe');
            if (iframe && fpContent && dockContainer) {
              // compute iframe position/size so floating player appears near it
              const rect = iframe.getBoundingClientRect();
              // show floating player and position it close to original iframe
              fp.style.display = 'block';
              fp.style.right = 'auto';
              fp.style.bottom = 'auto';
              // set a sensible initial size based on iframe or defaults
              fp.style.width = Math.max(320, rect.width) + 'px';
              // add extra room for the controls so they don't get hidden by overflow
              const controlsExtra = (vcControls && vcControls.offsetHeight) ? (vcControls.offsetHeight + 12) : 56;
              fp.style.height = Math.max(180, rect.height + controlsExtra) + 'px';
              // position using viewport coordinates
              fp.style.left = Math.max(8, rect.left) + 'px';
              // keep it visible a bit below header if necessary
              const headerOffset = 90; // matches sticky top offset
              fp.style.top = Math.max(headerOffset + 8, rect.top) + 'px';

              // now move iframe into floating content
              fpContent.appendChild(iframe);
              // move the controls (button) into the floating player but outside the iframe area
              // place it after the fpContent so it sits visually below the video frame
              if (vcControls) {
                const fpContentNode = fp.querySelector('.fp-content');
                fpContentNode.parentNode.insertBefore(vcControls, fpContentNode.nextSibling);
              }
              isFloating = true;
              fpToggleDock.textContent = 'Fixar';
            }
          }

          function deactivateFloating() {
            const iframe = fpContent.querySelector('iframe');
            if (iframe && fpContent && dockContainer) {
              // move iframe back to dock and hide floating container
              dockContainer.appendChild(iframe);
              // move controls (button) back below the docked iframe
              if (vcControls) dockContainer.appendChild(vcControls);
              fp.style.display = 'none';
              // clear inline positioning so CSS default (bottom-right) applies next time
              fp.style.left = '';
              fp.style.top = '';
              fp.style.right = '';
              fp.style.bottom = '';
              // leave width/height as-is so user resizing persists, or reset if needed
              isFloating = false;
              fpToggleDock.textContent = 'Janela Flutuante';
            }
          }

          // Wire dock toggle
          fpToggleDock.addEventListener('click', ()=>{
            if(isFloating) deactivateFloating(); else activateFloating();
          });

          // Dragging
          let dragging = false;
          let dragStartX = 0, dragStartY = 0, startLeft = 0, startTop = 0;

          header.addEventListener('pointerdown', (e)=>{
            dragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            const rect = fp.getBoundingClientRect();
            startLeft = rect.left;
            startTop = rect.top;
            fp.style.right = 'auto';
            fp.style.left = startLeft + 'px';
            fp.style.top = startTop + 'px';
            header.setPointerCapture(e.pointerId);
          });

          // Use document-level pointermove/up for robust dragging
          document.addEventListener('pointermove', (e)=>{
            if(dragging) {
              const dx = e.clientX - dragStartX;
              const dy = e.clientY - dragStartY;
              fp.style.left = (startLeft + dx) + 'px';
              fp.style.top = (startTop + dy) + 'px';
            }

            // resizing also handled here
            if(resizing && currentHandle) {
              let dx = e.clientX - startX;
              let dy = e.clientY - startY;
              let newW = startW;
              let newH = startH;

              if(currentHandle === handleBR) {
                newW = Math.max(320, startW + dx);
                newH = Math.max(180, startH + dy);
              } else {
                newW = Math.max(320, startW - dx);
                newH = Math.max(180, startH + dy);
              }

              fp.style.width = newW + 'px';
              fp.style.height = newH + 'px';
            }
          });

          document.addEventListener('pointerup', (e)=>{
            if(dragging) {
              dragging = false;
              try { header.releasePointerCapture(e.pointerId); } catch(e){}
            }
            if(resizing) {
              resizing = false;
              if(currentHandle) {
                try { currentHandle.releasePointerCapture(e.pointerId); } catch(e){}
              }
              currentHandle = null;
            }
          });

          // Ensure keyboard accessibility: ESC docks back
          document.addEventListener('keydown', (e)=>{
            if(e.key === 'Escape' && isFloating) deactivateFloating();
          });

          // Resize handlers for bottom-left (BL) and bottom-right (BR)
          const handleBL = document.getElementById('fpResizeHandleBL');
          const handleBR = document.getElementById('fpResizeHandleBR');
          let resizing = false;
          let currentHandle = null;
          let startW = 0, startH = 0, startX = 0, startY = 0;

          function onPointerDownHandle(e, handle) {
            resizing = true;
            currentHandle = handle;
            startW = fp.offsetWidth;
            startH = fp.offsetHeight;
            startX = e.clientX;
            startY = e.clientY;
            handle.setPointerCapture(e.pointerId);
            e.preventDefault();
          }

          function onPointerMoveHandle(e) {
            if(!resizing || !currentHandle) return;
            let dx = e.clientX - startX;
            let dy = e.clientY - startY;
            let newW = startW;
            let newH = startH;

            if(currentHandle === handleBR) {
              // bottom-right: moving right increases width, moving down increases height
              newW = Math.max(320, startW + dx);
              newH = Math.max(180, startH + dy);
            } else {
              // bottom-left: moving left increases width (dx negative), moving down increases height
              newW = Math.max(320, startW - dx);
              newH = Math.max(180, startH + dy);
            }

            fp.style.width = newW + 'px';
            fp.style.height = newH + 'px';
          }

          function onPointerUpHandle(e) {
            if(currentHandle) {
              try { currentHandle.releasePointerCapture(e.pointerId); } catch(e){}
            }
            resizing = false;
            currentHandle = null;
          }

          handleBR.addEventListener('pointerdown', (e)=> onPointerDownHandle(e, handleBR));
          handleBL.addEventListener('pointerdown', (e)=> onPointerDownHandle(e, handleBL));
          handleBR.addEventListener('pointermove', onPointerMoveHandle);
          handleBL.addEventListener('pointermove', onPointerMoveHandle);
          handleBR.addEventListener('pointerup', onPointerUpHandle);
          handleBL.addEventListener('pointerup', onPointerUpHandle);
        })();
      </script>

      
    </div>
  </body>
</html>
